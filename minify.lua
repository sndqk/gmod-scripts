local function a()end local function b(J)local K={}for L,M in pairs(J)do K[M]=true end return K end local function c(J,K)local L,M=0,next(J,nil)while M~=nil do L=L+1 if K and L>=K then break end M=next(J,M)end return L end local d='    'local function e(J)return string.rep(d,J or 0)end local function f(J,K,L)if type(J.Print)=='function'then return J.Print()end K=K or 0 L=L or function()return false end local M,N=1,c(J,2)>1 local O=e(K+1)local P={'{'}if N then table.insert(P,'\n')end for Q,R in pairs(J)do local S,T=type(Q),type(R)if T~='function'and not L(Q)then if N then table.insert(P,O)end if S=='string'then if Q:match("^[A-Za-z_][A-Za-z0-9_]*$")then table.insert(P,Q)else table.insert(P,'[\'')table.insert(P,Q)table.insert(P,'\']')end table.insert(P," = ")elseif S=='number'and Q==M then M=M+1 else table.insert(P,'[')table.insert(P,tostring(Q))table.insert(P,'] = ')end if T=='string'then table.insert(P,'\'')table.insert(P,R)table.insert(P,'\'')elseif T=='table'then table.insert(P,f(R,K+(N and 1 or 0),L))else table.insert(P,tostring(R))end if next(J,Q)then table.insert(P,',')end if N then table.insert(P,'\n')end end end if N then table.insert(P,e(K))end table.insert(P,'}')return table.concat(P)end local g=b{' ','\n','\t','\r','\b','\f','\v'}local h={['\r']='\\r',['\b']='\\b',['\f']='\\f',['\v']='\\v',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'",['\\']='\\'}local i={['r']='\r',['b']='\b',['f']='\f',['v']='\v',['n']='\n',['t']='\t',['"']='"',["'"]="'",['\\']='\\'}local j=b{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_'}local k=b{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','0','1','2','3','4','5','6','7','8','9'}local l=b{'0','1','2','3','4','5','6','7','8','9'}local m=b{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local n=b{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#','.',':'}local o=b{'~','!','=','>','<'}local p=b{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while','continue','&&','||'}local q=b{'else','elseif','until','end'}local r=b{'-','not','#','!'}local s=b{'+','-','*','/','%','^','#','..','.',':','>','<','<=','>=','~=','==','!=','and','or','&&','||'}local t={['+']={6,6},['-']={6,6},['*']={7,7},['/']={7,7},['%']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['~=']={3,3},['!=']={3,3},['>']={3,3},['<']={3,3},['>=']={3,3},['<=']={3,3},['and']={2,2},['&&']={2,2},['or']={1,1},['||']={1,1}}local u=8 local function v(J,K,L,M)L,M=L or 1,M or 0 if K>0 then if K>J:len()then K=J:len()end for N=1,K do M=M+1 if J:sub(N,N)=='\n'then L=L+1 M=0 end end if M==0 then M=1 end end return L,M end local function w(J)local K=1 local L={}local function M(U)U=K+(U or 0)return J:sub(U,U)end local function N()local U=J:sub(K,K)K=K+1 return U end local function O(U)local V,W=v(J,K)for X,Y in pairs(L)do print(Y.Type.."<"..Y.Source..">")end error("file<"..V..":"..W..">: "..U)end local function P(U)while true do local V=N()if V==''then O("Unfinished long string.")elseif V==']'then local W=true for X=1,U do if M()=='='then K=K+1 else W=false break end end if W and N()==']'then return end end end end local function Q()local U=0 while M(U)=='='do U=U+1 end if M(U)=='['then K=K+U+1 return U end return nil end local R,S local function T(U)local V={Type=U,LeadingWhite=J:sub(R,S-1),Source=J:sub(S,K-1)}table.insert(L,V)return V end while true do R=K while true do local V=M()if V==''then break elseif V=='-'then if M(1)=='-'then K=K+2 if M()=='['then K=K+1 local W=Q()if W then P(W)else local X repeat X=N()until X==''or X=='\n'end else local W repeat W=N()until W==''or W=='\n'end else break end elseif V=='/'then local W=M(1)if W=='*'then K=K+2 repeat W=N()if W=='*'and M()=='/'then N()break end until W==''elseif W=='/'then K=K+2 repeat W=N()until W==''or W=='\n'else break end elseif g[V]then K=K+1 else break end end S=K local U=N()if U==''then T('Eof')break elseif U=='\''or U=='\"'then local V repeat V=N()if V==''then O("Unfinished string.")elseif V=='\\'then local W=N()if not(l[W]or i[W])then O("Invalid Escape Sequence `"..W.."`.")end end until V==U T('String')elseif j[U]then while k[M()]do K=K+1 end if p[J:sub(S,K-1)]then T('Keyword')else T('Ident')end elseif l[U]or U=='.'and l[M()]then if U=='0'and M()=='x'then K=K+1 while m[M()]do K=K+1 end else while l[M()]do K=K+1 end if M()=='.'then K=K+1 while l[M()]do K=K+1 end end if M()=='e'or M()=='E'then K=K+1 if M()=='-'then K=K+1 end while l[M()]do K=K+1 end end end T('Number')elseif U=='['then local V=Q()if V then P(V)T('String')else T('Symbol')end elseif U=='.'then if M()=='.'then N()if M()=='.'then N()end end T('Symbol')elseif o[U]then if M()=='='then K=K+1 end T('Symbol')elseif U=='&'and M()=='&'or U=='|'and M()=='|'then N()T('Keyword')elseif n[U]then T('Symbol')else O("Bad symbol `"..U.."` in source.")end end return L end local function x(J)if type(J)=="string"then J=w(J)end assert(type(J)=="table")local K=1 local function L()local tb=J[K]if K<#J then K=K+1 end return tb end local function M(tb)tb=K+(tb or 0)return J[tb]or J[#J]end local function N(tb)local ub,vb=1,0 local wb=1 repeat local xb=J[wb]wb=wb+1 local yb=xb.LeadingWhite if xb~=tb then yb=yb..xb.Source end ub,vb=v(yb,#yb,ub,vb)until a4==tb return ub..":"..vb+1 end local function O()local tb=M()return"<"..tb.Type.." `"..tb.Source.."`> at: "..N(tb)end local function P()local tb=M()return tb.Type=='Eof'or tb.Type=='Keyword'and q[tb.Source]end local function Q()return r[M().Source]or false end local function R()return s[M().Source]or false end local function S(tb,ub,vb,wb)local xb=M()if xb.Type==tb and(ub==nil or xb.Source==ub)then return L()elseif xb.Type==vb and(wb==nil or xb.Source==wb)then return L()else for yb=-3,3 do print("Tokens["..yb.."] = `"..M(yb).Source.."`")end if ub then error(N(xb)..": `"..ub.."` expected.")else error(N(xb)..": "..tb..(vb and" or "..vb or"").." expected.")end end end local function T(tb)local function ub(xb)return xb.Token end local vb=tb.GetFirstToken or ub local wb=tb.GetLastToken or ub function tb:GetFirstToken()local xb=vb(self)assert(xb)return xb end function tb:GetLastToken()local xb=wb(self)assert(xb)return xb end return tb end local U,V local function W()local tb={}local ub={}table.insert(tb,V())while M().Source==','do table.insert(ub,L())table.insert(tb,V())end return tb,ub end local function X()local tb=M()if tb.Source=='('then local ub=L()local vb=V()local wb=S('Symbol',')')return T{Type='ParenExpr',Expression=vb,Token_OpenParen=ub,Token_CloseParen=wb,GetFirstToken=function(xb)return xb.Token_OpenParen end,GetLastToken=function(xb)return xb.Token_CloseParen end}elseif tb.Type=='Ident'then return T{Type='VariableExpr',Token=L()}else print(O())error(N(tb)..": Unexpected symbol")end end local function Y()local tb=S('Symbol','{')local ub={}local vb={}while M().Source~='}'do if M().Source=='['then local xb=L()local yb=V()local zb=S('Symbol',']')local Ab=S('Symbol','=')local Bb=V()table.insert(ub,{EntryType='Index',Index=yb,Value=Bb,Token_OpenBracket=xb,Token_CloseBracket=zb,Token_Equals=Ab})elseif M().Type=='Ident'and M(1).Source=='='then local xb=L()local yb=L()local zb=V()table.insert(ub,{EntryType='Field',Field=xb,Value=zb,Token_Equals=yb})else local xb=V()table.insert(ub,{EntryType='Value',Value=xb})end if M().Source==','or M().Source==';'then table.insert(vb,L())else break end end local wb=S('Symbol','}')return T{Type='TableLiteral',EntryList=ub,Token_SeparatorList=vb,Token_OpenBrace=tb,Token_CloseBrace=wb,GetFirstToken=function(xb)return xb.Token_OpenBrace end,GetLastToken=function(xb)return xb.Token_CloseBrace end}end local function Z(tb)local ub,vb,wb={},{},M()if wb.Type=='Ident'then table.insert(ub,L())elseif tb and wb.Source=='...'then table.insert(ub,L())end while M().Source==','do table.insert(vb,L())if tb then wb=S('Ident',nil,'Symbol','...')else wb=S('Ident')end table.insert(ub,wb)end return ub,vb end local function ab(tb)local ub=U()local vb=M()if vb.Type=='Keyword'and vb.Source==tb then L()return ub,vb else print(vb.Type,vb.Source)error(N(vb)..": "..tb.." expected.")end end local function bb(tb)local ub=L()local vb,wb if not tb then vb={}wb={}table.insert(vb,S('Ident'))while M().Source=='.'do table.insert(wb,L())table.insert(vb,S('Ident'))end if M().Source==':'then table.insert(wb,L())table.insert(vb,S('Ident'))end end local xb=S('Symbol','(')local yb,zb=Z(true)local Ab=S('Symbol',')')local Bb,Cb=ab('end')return T{Type=tb and'FunctionLiteral'or'FunctionStat',NameChain=vb,ArgList=yb,Body=Bb,Token_Function=ub,Token_NameChainSeparator=wb,Token_OpenParen=xb,Token_ArgCommaList=zb,Token_CloseParen=Ab,Token_End=Cb,GetFirstToken=function(Db)return Db.Token_Function end,GetLastToken=function(Db)return Db.Token_End end}end local function cb()local tb=M()if tb.Source=='('then local ub=L()local vb={}local wb={}while M().Source~=')'do table.insert(vb,V())if M().Source==','then table.insert(wb,L())else break end end local xb=S('Symbol',')')return T{CallType='ArgCall',ArgList=vb,Token_CommaList=wb,Token_OpenParen=ub,Token_CloseParen=xb,GetFirstToken=function(yb)return yb.Token_OpenParen end,GetLastToken=function(yb)return yb.Token_CloseParen end}elseif tb.Source=='{'then return T{CallType='TableCall',TableExpr=V(),GetFirstToken=function(ub)return ub.TableExpr:GetFirstToken()end,GetLastToken=function(ub)return ub.TableExpr:GetLastToken()end}elseif tb.Type=='String'then return T{CallType='StringCall',Token=L()}else error("Function arguments expected.")end end local function db(tb)return T{Type='CallExpr',Base=tb,FunctionArguments=cb(),GetFirstToken=function(ub)return ub.Base:GetFirstToken()end,GetLastToken=function(ub)return ub.FunctionArguments:GetLastToken()end}end local function eb()local tb=X()assert(tb,"nil prefixexpr")while true do local ub=M()if ub.Source=='.'then local vb=L()local wb=S('Ident')tb=T{Type='FieldExpr',Base=tb,Field=wb,Token_Dot=vb,GetFirstToken=function(xb)return xb.Base:GetFirstToken()end,GetLastToken=function(xb)return xb.Field end}elseif ub.Source==':'then local vb=L()local wb=S('Ident')local xb=cb()tb=T{Type='MethodExpr',Base=tb,Method=wb,FunctionArguments=xb,Token_Colon=vb,GetFirstToken=function(yb)return yb.Base:GetFirstToken()end,GetLastToken=function(yb)return yb.FunctionArguments:GetLastToken()end}elseif ub.Source=='['then local vb=L()local wb=V()local xb=S('Symbol',']')tb=T{Type='IndexExpr',Base=tb,Index=wb,Token_OpenBracket=vb,Token_CloseBracket=xb,GetFirstToken=function(yb)return yb.Base:GetFirstToken()end,GetLastToken=function(yb)return yb.Token_CloseBracket end}elseif ub.Source=='{'then tb=db(tb)elseif ub.Source=='('then tb=db(tb)elseif ub.Type=='String'then tb=db(tb)else return tb end end end local function fb(tb)return T{Type=tb,Token=L()}end local function gb()local tb=M()if tb.Type=='Number'then return fb('NumberLiteral')elseif tb.Type=='String'then return fb('StringLiteral')elseif tb.Source=='nil'then return fb('NilLiteral')elseif tb.Source=='true'or tb.Source=='false'then return fb('BooleanLiteral')elseif tb.Source=='...'then return fb('VargLiteral')elseif tb.Source=='{'then return Y()elseif tb.Source=='function'then return bb(true)else return eb()end end local function hb(tb)local ub if Q()then local vb=L()local wb=hb(u)ub=T{Type='UnopExpr',Token_Op=vb,Rhs=wb,GetFirstToken=function(xb)return xb.Token_Op end,GetLastToken=function(xb)return xb.Rhs:GetLastToken()end}else ub=gb()assert(ub,"nil simpleexpr")end while R()and t[M().Source][1]>tb do local vb=L()local wb=hb(t[vb.Source][2])assert(wb,"RhsNeeded")ub=T{Type='BinopExpr',Lhs=ub,Rhs=wb,Token_Op=vb,GetFirstToken=function(xb)return xb.Lhs:GetFirstToken()end,GetLastToken=function(xb)return xb.Rhs:GetLastToken()end}end return ub end V=function()return hb(0)end local function ib()local tb=eb()if tb.Type=='MethodExpr'or tb.Type=='CallExpr'then return T{Type='CallExprStat',Expression=tb,GetFirstToken=function(ub)return ub.Expression:GetFirstToken()end,GetLastToken=function(ub)return ub.Expression:GetLastToken()end}else local ub={tb}local vb={}while M().Source==','do table.insert(vb,L())local zb=eb()if zb.Type=='MethodExpr'or zb.Type=='CallExpr'then error("Bad left hand side of assignment")end table.insert(ub,zb)end local wb=S('Symbol','=')local xb={V()}local yb={}while M().Source==','do table.insert(yb,L())table.insert(xb,V())end return T{Type='AssignmentStat',Rhs=xb,Lhs=ub,Token_Equals=wb,Token_LhsSeparatorList=vb,Token_RhsSeparatorList=yb,GetFirstToken=function(zb)return zb.Lhs[1]:GetFirstToken()end,GetLastToken=function(zb)return zb.Rhs[#zb.Rhs]:GetLastToken()end}end end local function jb()local tb=L()local ub=V()local vb=S('Keyword','then')local wb=U()local xb={}while M().Source=='elseif'or M().Source=='else'do local zb=L()local Ab,Bb if zb.Source=='elseif'then Ab=V()Bb=S('Keyword','then')end local Cb=U()table.insert(xb,{Condition=Ab,Body=Cb,ClauseType=zb.Source,Token=zb,Token_Then=Bb})if zb.Source=='else'then break end end local yb=S('Keyword','end')return T{Type='IfStat',Condition=ub,Body=wb,ElseClauseList=xb,Token_If=tb,Token_Then=vb,Token_End=yb,GetFirstToken=function(zb)return zb.Token_If end,GetLastToken=function(zb)return zb.Token_End end}end local function kb()local tb=L()local ub,vb=ab('end')return T{Type='DoStat',Body=ub,Token_Do=tb,Token_End=vb,GetFirstToken=function(wb)return wb.Token_Do end,GetLastToken=function(wb)return wb.Token_End end}end local function lb()local tb=L()local ub=V()local vb=S('Keyword','do')local wb,xb=ab('end')return T{Type='WhileStat',Condition=ub,Body=wb,Token_While=tb,Token_Do=vb,Token_End=xb,GetFirstToken=function(yb)return yb.Token_While end,GetLastToken=function(yb)return yb.Token_End end}end local function mb()local tb=L()local ub,vb=Z()if M().Source=='='then local wb=L()local xb,yb=W()if#xb<2 or#xb>3 then error("expected 2 or 3 values for range bounds")end local zb=S('Keyword','do')local Ab,Bb=ab('end')return T{Type='NumericForStat',VarList=ub,RangeList=xb,Body=Ab,Token_For=tb,Token_VarCommaList=vb,Token_Equals=wb,Token_RangeCommaList=yb,Token_Do=zb,Token_End=Bb,GetFirstToken=function(Cb)return Cb.Token_For end,GetLastToken=function(Cb)return Cb.Token_End end}elseif M().Source=='in'then local wb=L()local xb,yb=W()local zb=S('Keyword','do')local Ab,Bb=ab('end')return T{Type='GenericForStat',VarList=ub,GeneratorList=xb,Body=Ab,Token_For=tb,Token_VarCommaList=vb,Token_In=wb,Token_GeneratorCommaList=yb,Token_Do=zb,Token_End=Bb,GetFirstToken=function(Cb)return Cb.Token_For end,GetLastToken=function(Cb)return Cb.Token_End end}else error("`=` or in expected")end end local function nb()local tb=L()local ub,vb=ab('until')local wb=V()return T{Type='RepeatStat',Body=ub,Condition=wb,Token_Repeat=tb,Token_Until=vb,GetFirstToken=function(xb)return xb.Token_Repeat end,GetLastToken=function(xb)return xb.Condition:GetLastToken()end}end local function ob()local tb=L()if M().Source=='function'then local ub=bb(false)if#ub.NameChain>1 then error(N(ub.Token_NameChainSeparator[1])..": `(` expected.")end return T{Type='LocalFunctionStat',FunctionStat=ub,Token_Local=tb,GetFirstToken=function(vb)return vb.Token_Local end,GetLastToken=function(vb)return vb.FunctionStat:GetLastToken()end}elseif M().Type=='Ident'then local ub,vb=Z()local wb,xb={},{}local yb if M().Source=='='then yb=L()wb,xb=W()end return T{Type='LocalVarStat',VarList=ub,ExprList=wb,Token_Local=tb,Token_Equals=yb,Token_VarCommaList=vb,Token_ExprCommaList=xb,GetFirstToken=function(zb)return zb.Token_Local end,GetLastToken=function(zb)if#zb.ExprList>0 then return zb.ExprList[#zb.ExprList]:GetLastToken()else return zb.VarList[#zb.VarList]end end}else error("`function` or ident expected")end end local function pb()local tb=L()local ub,vb if P()or M().Source==';'then ub={}vb={}else ub,vb=W()end return{Type='ReturnStat',ExprList=ub,Token_Return=tb,Token_CommaList=vb,GetFirstToken=function(wb)return wb.Token_Return end,GetLastToken=function(wb)if#wb.ExprList>0 then return wb.ExprList[#wb.ExprList]:GetLastToken()else return wb.Token_Return end end}end local function qb()local tb=L()return{Type='BreakStat',Token_Break=tb,GetFirstToken=function(ub)return ub.Token_Break end,GetLastToken=function(ub)return ub.Token_Break end}end local function rb()local tb=L()return{Type='ContinueStat',Token_Continue=tb,GetFirstToken=function(ub)return ub.Token_Continue end,GetLastToken=function(ub)return ub.Token_Continue end}end local function sb()local tb=M()if tb.Source=='if'then return false,jb()elseif tb.Source=='while'then return false,lb()elseif tb.Source=='do'then return false,kb()elseif tb.Source=='for'then return false,mb()elseif tb.Source=='repeat'then return false,nb()elseif tb.Source=='function'then return false,bb(false)elseif tb.Source=='local'then return false,ob()elseif tb.Source=='return'then return true,pb()elseif tb.Source=='break'then return true,qb()elseif tb.Source=='continue'then return true,rb()else return false,ib()end end U=function()local tb={}local ub={}local vb=false while not vb and not P()do local wb vb,wb=sb()table.insert(tb,wb)local xb=M()if xb.Type=='Symbol'and xb.Source==';'then ub[#tb]=L()end end return{Type='StatList',StatementList=tb,SemicolonList=ub,GetFirstToken=function(wb)if#wb.StatementList==0 then return nil else return wb.StatementList[1]:GetFirstToken()end end,GetLastToken=function(wb)if#wb.StatementList==0 then return nil elseif wb.SemicolonList[#wb.StatementList]then return wb.SemicolonList[#wb.StatementList]else return wb.StatementList[#wb.StatementList]:GetLastToken()end end}end return U()end local function y(J,K)local L=b{'BinopExpr','UnopExpr','NumberLiteral','StringLiteral','NilLiteral','BooleanLiteral','VargLiteral','FieldExpr','IndexExpr','MethodExpr','CallExpr','FunctionLiteral','VariableExpr','ParenExpr','TableLiteral'}local M=b{'StatList','ContinueStat','BreakStat','ReturnStat','LocalVarStat','LocalFunctionStat','FunctionStat','RepeatStat','GenericForStat','NumericForStat','WhileStat','DoStat','IfStat','CallExprStat','AssignmentStat'}for R,S in pairs(K)do if not M[R]and not L[R]then error("Invalid visitor target: `"..R.."`")end end local function N(R)local S=K[R.Type]if type(S)=='function'then return S(R)elseif S and S.Pre then return S.Pre(R)end end local function O(R)local S=K[R.Type]if S and type(S)=='table'and S.Post then return S.Post(R)end end local P,Q P=function(R)if N(R)then return end if R.Type=='BinopExpr'then P(R.Lhs)P(R.Rhs)elseif R.Type=='UnopExpr'then P(R.Rhs)elseif R.Type=='NumberLiteral'or R.Type=='StringLiteral'or R.Type=='NilLiteral'or R.Type=='BooleanLiteral'or R.Type=='VargLiteral'then a()elseif R.Type=='FieldExpr'then P(R.Base)elseif R.Type=='IndexExpr'then P(R.Base)P(R.Index)elseif R.Type=='MethodExpr'or R.Type=='CallExpr'then P(R.Base)if R.FunctionArguments.CallType=='ArgCall'then for S,T in pairs(R.FunctionArguments.ArgList)do P(T)end elseif R.FunctionArguments.CallType=='TableCall'then P(R.FunctionArguments.TableExpr)end elseif R.Type=='FunctionLiteral'then Q(R.Body)elseif R.Type=='VariableExpr'then a()elseif R.Type=='ParenExpr'then P(R.Expression)elseif R.Type=='TableLiteral'then for S,T in pairs(R.EntryList)do if T.EntryType=='Field'then P(T.Value)elseif T.EntryType=='Index'then P(T.Index)P(T.Value)elseif T.EntryType=='Value'then P(T.Value)else assert(false,"unreachable")end end else assert(false,"unreachable, type: "..R.Type..":"..f(R))end O(R)end Q=function(R)if N(R)then return end if R.Type=='StatList'then for S,T in pairs(R.StatementList)do Q(T)end elseif R.Type=='BreakStat'or R.Type=='ContinueStat'then a()elseif R.Type=='ReturnStat'then for S,T in pairs(R.ExprList)do P(T)end elseif R.Type=='LocalVarStat'then if R.Token_Equals then for S,T in pairs(R.ExprList)do P(T)end end elseif R.Type=='LocalFunctionStat'then Q(R.FunctionStat.Body)elseif R.Type=='FunctionStat'then Q(R.Body)elseif R.Type=='RepeatStat'then Q(R.Body)P(R.Condition)elseif R.Type=='GenericForStat'then for S,T in pairs(R.GeneratorList)do P(T)end Q(R.Body)elseif R.Type=='NumericForStat'then for S,T in pairs(R.RangeList)do P(T)end Q(R.Body)elseif R.Type=='WhileStat'then P(R.Condition)Q(R.Body)elseif R.Type=='DoStat'then Q(R.Body)elseif R.Type=='IfStat'then P(R.Condition)Q(R.Body)for S,T in pairs(R.ElseClauseList)do if T.Condition then P(T.Condition)end Q(T.Body)end elseif R.Type=='CallExprStat'then P(R.Expression)elseif R.Type=='AssignmentStat'then for S,T in pairs(R.Lhs)do P(T)end for S,T in pairs(R.Rhs)do P(T)end else assert(false,"unreachable")end O(R)end if M[J.Type]then Q(J)else P(J)end end local function z(J)local K={}local L=nil local M=0 local function N()M=M+1 return M end local function O()L={ParentScope=L,ChildScopeList={},VariableList={},BeginLocation=N()}if L.ParentScope then L.Depth=L.ParentScope.Depth+1 table.insert(L.ParentScope.ChildScopeList,L)else L.Depth=1 end function L:GetVar(W)for X,Y in pairs(self.VariableList)do if Y.Name==W then return Y end end if self.ParentScope then return self.ParentScope:GetVar(W)else for X,Y in pairs(K)do if Y.Name==W then return Y end end end end end local function P()local W=L W.EndLocation=N()for X,Y in pairs(W.VariableList)do Y.ScopeEndLocation=W.EndLocation end L=W.ParentScope return W end O()local function Q(W,X,Y)assert(Y,"Missing localInfo")assert(W,"Missing local var name")local Z={Type='Local',Name=W,RenameList={X},AssignedTo=false,Info=Y,UseCount=0,Scope=L,BeginLocation=N(),EndLocation=N(),ReferenceLocationList={N()}}function Z:Rename(ab)self.Name=ab for bb,cb in pairs(self.RenameList)do cb(ab)end end function Z:Reference()self.UseCount=self.UseCount+1 end table.insert(L.VariableList,Z)return Z end local function R(W)for Y,Z in pairs(K)do if Z.Name==W then return Z end end local X={Type='Global',Name=W,RenameList={},AssignedTo=false,UseCount=0,Scope=nil,BeginLocation=N(),EndLocation=N(),ReferenceLocationList={}}function X:Rename(Y)self.Name=Y for Z,ab in pairs(self.RenameList)do ab(Y)end end function X:Reference()self.UseCount=self.UseCount+1 end table.insert(K,X)return X end local function S(W,X)assert(W,"Missing var name")local Y=R(W)table.insert(Y.RenameList,X)return Y end local function T(W,X)for Y=#W.VariableList,1,-1 do if W.VariableList[Y].Name==X then return W.VariableList[Y]end end if W.ParentScope then local Y=T(W.ParentScope,X)if Y then return Y end end return nil end local function U(W,X)assert(W,"Missing var name")local Y=T(L,W)if Y then table.insert(Y.RenameList,X)else Y=S(W,X)end local Z=N()Y.EndLocation=Z table.insert(Y.ReferenceLocationList,Y.EndLocation)return Y end local V={}V.FunctionLiteral={Pre=function(W)O()for X,Y in pairs(W.ArgList)do if Y.Type=='Ident'then Q(Y.Source,function(Z)Y.Source=Z end,{Type='Argument',Index=X})end end end,Post=function()P()end}V.VariableExpr=function(W)W.Variable=U(W.Token.Source,function(X)W.Token.Source=X end)end V.StatList={Pre=function()O()end,Post=function()P()end}V.LocalVarStat={Post=function(W)for X,Y in pairs(W.VarList)do Q(Y.Source,function(Z)W.VarList[X].Source=Z end,{Type='Local'})end end}V.LocalFunctionStat={Pre=function(W)Q(W.FunctionStat.NameChain[1].Source,function(X)W.FunctionStat.NameChain[1].Source=X end,{Type='LocalFunction'})O()for X,Y in pairs(W.FunctionStat.ArgList)do if Y.Type=='Ident'then Q(Y.Source,function(Z)Y.Source=Z end,{Type='Argument',Index=X})end end end,Post=function()P()end}V.FunctionStat={Pre=function(W)local X=W.NameChain local Y if#X==1 then Y=S(X[1].Source,function(Z)X[1].Source=Z end)else Y=U(X[1].Source,function(Z)X[1].Source=Z end)end Y.AssignedTo=true O()for Z,ab in pairs(W.ArgList)do if ab.Type=='Ident'then Q(ab.Source,function(bb)ab.Source=bb end,{Type='Argument',Index=Z})end end end,Post=function()P()end}V.GenericForStat={Pre=function(W)for X,Y in pairs(W.GeneratorList)do y(Y,V)end O()for X,Y in pairs(W.VarList)do Q(Y.Source,function(Z)Y.Source=Z end,{Type='ForRange',Index=X})end y(W.Body,V)P()return true end}V.NumericForStat={Pre=function(W)for X,Y in pairs(W.RangeList)do y(Y,V)end O()for X,Y in pairs(W.VarList)do Q(Y.Source,function(Z)Y.Source=Z end,{Type='ForRange',Index=X})end y(W.Body,V)P()return true end}V.AssignmentStat={Post=function(W)for X,Y in pairs(W.Lhs)do if Y.Variable then Y.Variable.AssignedTo=true end end end}y(J,V)return K,P()end local function A(J,K)local L,M local N=''local function O(P)if not P.LeadingWhite or not P.Source then error("Bad token: "..f(P))end if K then table.insert(K,P.LeadingWhite)table.insert(K,P.Source)else N=N..P.LeadingWhite N=N..P.Source end end M=function(P)if P.Type=='BinopExpr'then M(P.Lhs)O(P.Token_Op)M(P.Rhs)elseif P.Type=='UnopExpr'then O(P.Token_Op)M(P.Rhs)elseif P.Type=='NumberLiteral'or P.Type=='StringLiteral'or P.Type=='NilLiteral'or P.Type=='BooleanLiteral'or P.Type=='VargLiteral'then O(P.Token)elseif P.Type=='FieldExpr'then M(P.Base)O(P.Token_Dot)O(P.Field)elseif P.Type=='IndexExpr'then M(P.Base)O(P.Token_OpenBracket)M(P.Index)O(P.Token_CloseBracket)elseif P.Type=='MethodExpr'or P.Type=='CallExpr'then M(P.Base)if P.Type=='MethodExpr'then O(P.Token_Colon)O(P.Method)end if P.FunctionArguments.CallType=='StringCall'then O(P.FunctionArguments.Token)elseif P.FunctionArguments.CallType=='ArgCall'then O(P.FunctionArguments.Token_OpenParen)for Q,R in pairs(P.FunctionArguments.ArgList)do M(R)local S=P.FunctionArguments.Token_CommaList[Q]if S then O(S)end end O(P.FunctionArguments.Token_CloseParen)elseif P.FunctionArguments.CallType=='TableCall'then M(P.FunctionArguments.TableExpr)end elseif P.Type=='FunctionLiteral'then O(P.Token_Function)O(P.Token_OpenParen)for Q,R in pairs(P.ArgList)do O(R)local S=P.Token_ArgCommaList[Q]if S then O(S)end end O(P.Token_CloseParen)L(P.Body)O(P.Token_End)elseif P.Type=='VariableExpr'then O(P.Token)elseif P.Type=='ParenExpr'then O(P.Token_OpenParen)M(P.Expression)O(P.Token_CloseParen)elseif P.Type=='TableLiteral'then O(P.Token_OpenBrace)for Q,R in pairs(P.EntryList)do if R.EntryType=='Field'then O(R.Field)O(R.Token_Equals)M(R.Value)elseif R.EntryType=='Index'then O(R.Token_OpenBracket)M(R.Index)O(R.Token_CloseBracket)O(R.Token_Equals)M(R.Value)elseif R.EntryType=='Value'then M(R.Value)else assert(false,"unreachable")end local S=P.Token_SeparatorList[Q]if S then O(S)end end O(P.Token_CloseBrace)else assert(false,"unreachable, type: "..P.Type..":"..f(P))end end L=function(P)if P.Type=='StatList'then for Q,R in pairs(P.StatementList)do L(R)if P.SemicolonList[Q]then O(P.SemicolonList[Q])end end elseif P.Type=='BreakStat'then O(P.Token_Break)elseif P.Type=='ContinueStat'then O(P.Token_Continue)elseif P.Type=='ReturnStat'then O(P.Token_Return)for Q,R in pairs(P.ExprList)do M(R)if P.Token_CommaList[Q]then O(P.Token_CommaList[Q])end end elseif P.Type=='LocalVarStat'then O(P.Token_Local)for Q,R in pairs(P.VarList)do O(R)local S=P.Token_VarCommaList[Q]if S then O(S)end end if P.Token_Equals then O(P.Token_Equals)for Q,R in pairs(P.ExprList)do M(R)local S=P.Token_ExprCommaList[Q]if S then O(S)end end end elseif P.Type=='LocalFunctionStat'then O(P.Token_Local)O(P.FunctionStat.Token_Function)O(P.FunctionStat.NameChain[1])O(P.FunctionStat.Token_OpenParen)for Q,R in pairs(P.FunctionStat.ArgList)do O(R)local S=P.FunctionStat.Token_ArgCommaList[Q]if S then O(S)end end O(P.FunctionStat.Token_CloseParen)L(P.FunctionStat.Body)O(P.FunctionStat.Token_End)elseif P.Type=='FunctionStat'then O(P.Token_Function)for Q,R in pairs(P.NameChain)do O(R)local S=P.Token_NameChainSeparator[Q]if S then O(S)end end O(P.Token_OpenParen)for Q,R in pairs(P.ArgList)do O(R)local S=P.Token_ArgCommaList[Q]if S then O(S)end end O(P.Token_CloseParen)L(P.Body)O(P.Token_End)elseif P.Type=='RepeatStat'then O(P.Token_Repeat)L(P.Body)O(P.Token_Until)M(P.Condition)elseif P.Type=='GenericForStat'then O(P.Token_For)for Q,R in pairs(P.VarList)do O(R)local S=P.Token_VarCommaList[Q]if S then O(S)end end O(P.Token_In)for Q,R in pairs(P.GeneratorList)do M(R)local S=P.Token_GeneratorCommaList[Q]if S then O(S)end end O(P.Token_Do)L(P.Body)O(P.Token_End)elseif P.Type=='NumericForStat'then O(P.Token_For)for Q,R in pairs(P.VarList)do O(R)local S=P.Token_VarCommaList[Q]if S then O(S)end end O(P.Token_Equals)for Q,R in pairs(P.RangeList)do M(R)local S=P.Token_RangeCommaList[Q]if S then O(S)end end O(P.Token_Do)L(P.Body)O(P.Token_End)elseif P.Type=='WhileStat'then O(P.Token_While)M(P.Condition)O(P.Token_Do)L(P.Body)O(P.Token_End)elseif P.Type=='DoStat'then O(P.Token_Do)L(P.Body)O(P.Token_End)elseif P.Type=='IfStat'then O(P.Token_If)M(P.Condition)O(P.Token_Then)L(P.Body)for Q,R in pairs(P.ElseClauseList)do O(R.Token)if R.Condition then M(R.Condition)O(R.Token_Then)end L(R.Body)end O(P.Token_End)elseif P.Type=='CallExprStat'then M(P.Expression)elseif P.Type=='AssignmentStat'then for Q,R in pairs(P.Lhs)do M(R)local S=P.Token_LhsSeparatorList[Q]if S then O(S)end end O(P.Token_Equals)for Q,R in pairs(P.Rhs)do M(R)local S=P.Token_RhsSeparatorList[Q]if S then O(S)end end else assert(false,"unreachable")end end L(J)return N end local function B(J)local K={}A(J,K)return table.concat(K)end local function C(J)local K,L local M=0 local function N(U)local V='\n'..('\t'):rep(M)if U.LeadingWhite==''or U.LeadingWhite:sub(-#V,-1)~=V then U.LeadingWhite=U.LeadingWhite:gsub("\n?[\t ]*$","")U.LeadingWhite=U.LeadingWhite..V end end local function O()M=M+1 end local function P()M=M-1 assert(M>=0,"Undented too far")end local function Q(U)if#U.LeadingWhite>0 then return U.LeadingWhite:sub(1,1)else return U.Source:sub(1,1)end end local function R(U)if not g[Q(U)]then U.LeadingWhite=' '..U.LeadingWhite end end local function S(U)R(U:GetFirstToken())end local function T(U,V,W)O()K(V)P()N(W)end L=function(U)if U.Type=='BinopExpr'then L(U.Lhs)L(U.Rhs)if U.Token_Op.Source~='..'then S(U.Rhs)R(U.Token_Op)end elseif U.Type=='UnopExpr'then L(U.Rhs)elseif U.Type=='NumberLiteral'or U.Type=='StringLiteral'or U.Type=='NilLiteral'or U.Type=='BooleanLiteral'or U.Type=='VargLiteral'then a()elseif U.Type=='FieldExpr'then L(U.Base)elseif U.Type=='IndexExpr'then L(U.Base)L(U.Index)elseif U.Type=='MethodExpr'or U.Type=='CallExpr'then L(U.Base)if U.Type=='MethodExpr'then a()end if U.FunctionArguments.CallType=='StringCall'then a()elseif U.FunctionArguments.CallType=='ArgCall'then for V,W in pairs(U.FunctionArguments.ArgList)do L(W)if V>1 then S(W)end end elseif U.FunctionArguments.CallType=='TableCall'then L(U.FunctionArguments.TableExpr)end elseif U.Type=='FunctionLiteral'then for V,W in pairs(U.ArgList)do if V>1 then R(W)end end T(U.Token_CloseParen,U.Body,U.Token_End)elseif U.Type=='VariableExpr'then a()elseif U.Type=='ParenExpr'then L(U.Expression)elseif U.Type=='TableLiteral'then if#U.EntryList>0 then O()for V,W in pairs(U.EntryList)do if W.EntryType=='Field'then N(W.Field)R(W.Token_Equals)L(W.Value)S(W.Value)elseif W.EntryType=='Index'then N(W.Token_OpenBracket)L(W.Index)R(W.Token_Equals)L(W.Value)S(W.Value)elseif W.EntryType=='Value'then L(W.Value)N(W.Value:GetFirstToken())else assert(false,"unreachable")end end P()N(U.Token_CloseBrace)end else assert(false,"unreachable, type: "..U.Type..":"..f(U))end end K=function(U)if U.Type=='StatList'then for V,W in pairs(U.StatementList)do K(W)N(W:GetFirstToken())end elseif U.Type=='BreakStat'or U.Type=='ContinueStat'then a()elseif U.Type=='ReturnStat'then for V,W in pairs(U.ExprList)do L(W)S(W)if U.Token_CommaList[V]then a()end end elseif U.Type=='LocalVarStat'then for V,W in pairs(U.VarList)do R(W)end if U.Token_Equals then R(U.Token_Equals)for V,W in pairs(U.ExprList)do L(W)S(W)end end elseif U.Type=='LocalFunctionStat'then R(U.FunctionStat.Token_Function)R(U.FunctionStat.NameChain[1])for V,W in pairs(U.FunctionStat.ArgList)do if V>1 then R(W)end end T(U.FunctionStat.Token_CloseParen,U.FunctionStat.Body,U.FunctionStat.Token_End)elseif U.Type=='FunctionStat'then for V,W in pairs(U.NameChain)do if V==1 then R(W)end end for V,W in pairs(U.ArgList)do if V>1 then R(W)end end T(U.Token_CloseParen,U.Body,U.Token_End)elseif U.Type=='RepeatStat'then T(U.Token_Repeat,U.Body,U.Token_Until)L(U.Condition)S(U.Condition)elseif U.Type=='GenericForStat'then for V,W in pairs(U.VarList)do R(W)end R(U.Token_In)for V,W in pairs(U.GeneratorList)do L(W)S(W)end R(U.Token_Do)T(U.Token_Do,U.Body,U.Token_End)elseif U.Type=='NumericForStat'then for V,W in pairs(U.VarList)do R(W)end R(U.Token_Equals)for V,W in pairs(U.RangeList)do L(W)S(W)end R(U.Token_Do)T(U.Token_Do,U.Body,U.Token_End)elseif U.Type=='WhileStat'then L(U.Condition)S(U.Condition)R(U.Token_Do)T(U.Token_Do,U.Body,U.Token_End)elseif U.Type=='DoStat'then T(U.Token_Do,U.Body,U.Token_End)elseif U.Type=='IfStat'then L(U.Condition)S(U.Condition)R(U.Token_Then)local V=U.Token_Then local W=U.Body for X,Y in pairs(U.ElseClauseList)do T(V,W,Y.Token)V=Y.Token if Y.Condition then L(Y.Condition)S(Y.Condition)R(Y.Token_Then)V=Y.Token_Then end W=Y.Body end T(V,W,U.Token_End)elseif U.Type=='CallExprStat'then L(U.Expression)elseif U.Type=='AssignmentStat'then for V,W in pairs(U.Lhs)do L(W)if V>1 then S(W)end end R(U.Token_Equals)for V,W in pairs(U.Rhs)do L(W)S(W)end else assert(false,"unreachable")end end K(J)return str end local function D(J)local K,L local function M(P)P.LeadingWhite=''end local function N(P,Q)M(Q)local R=P.Source:sub(-1,-1)local S=Q.Source:sub(1,1)if R=='-'and S=='-'or k[R]and k[S]then Q.LeadingWhite=' 'else Q.LeadingWhite=''end end local function O(P,Q,R)K(Q)M(R)local S=Q:GetFirstToken()local T=Q:GetLastToken()if S then N(P,S)N(T,R)else N(P,R)end end L=function(P)if P.Type=='BinopExpr'then L(P.Lhs)M(P.Token_Op)L(P.Rhs)N(P.Token_Op,P.Rhs:GetFirstToken())N(P.Lhs:GetLastToken(),P.Token_Op)elseif P.Type=='UnopExpr'then M(P.Token_Op)L(P.Rhs)N(P.Token_Op,P.Rhs:GetFirstToken())elseif P.Type=='NumberLiteral'or P.Type=='StringLiteral'or P.Type=='NilLiteral'or P.Type=='BooleanLiteral'or P.Type=='VargLiteral'then M(P.Token)elseif P.Type=='FieldExpr'then L(P.Base)M(P.Token_Dot)M(P.Field)elseif P.Type=='IndexExpr'then L(P.Base)M(P.Token_OpenBracket)L(P.Index)M(P.Token_CloseBracket)elseif P.Type=='MethodExpr'or P.Type=='CallExpr'then L(P.Base)if P.Type=='MethodExpr'then M(P.Token_Colon)M(P.Method)end if P.FunctionArguments.CallType=='StringCall'then M(P.FunctionArguments.Token)elseif P.FunctionArguments.CallType=='ArgCall'then M(P.FunctionArguments.Token_OpenParen)for Q,R in pairs(P.FunctionArguments.ArgList)do L(R)local S=P.FunctionArguments.Token_CommaList[Q]if S then M(S)end end M(P.FunctionArguments.Token_CloseParen)elseif P.FunctionArguments.CallType=='TableCall'then L(P.FunctionArguments.TableExpr)end elseif P.Type=='FunctionLiteral'then M(P.Token_Function)M(P.Token_OpenParen)for Q,R in pairs(P.ArgList)do M(R)local S=P.Token_ArgCommaList[Q]if S then M(S)end end M(P.Token_CloseParen)O(P.Token_CloseParen,P.Body,P.Token_End)elseif P.Type=='VariableExpr'then M(P.Token)elseif P.Type=='ParenExpr'then M(P.Token_OpenParen)L(P.Expression)M(P.Token_CloseParen)elseif P.Type=='TableLiteral'then M(P.Token_OpenBrace)for Q,R in pairs(P.EntryList)do if R.EntryType=='Field'then M(R.Field)M(R.Token_Equals)L(R.Value)elseif R.EntryType=='Index'then M(R.Token_OpenBracket)L(R.Index)M(R.Token_CloseBracket)M(R.Token_Equals)L(R.Value)elseif R.EntryType=='Value'then L(R.Value)else assert(false,"unreachable")end local S=P.Token_SeparatorList[Q]if S then M(S)end end M(P.Token_CloseBrace)else assert(false,"unreachable, type: "..P.Type..":"..f(P))end end K=function(P)if P.Type=='StatList'then for Q=1,#P.StatementList do local R=P.StatementList[Q]K(R)M(R:GetFirstToken())local S=P.StatementList[Q-1]if S then if P.SemicolonList[Q-1]and(S:GetLastToken().Source~=')'or R:GetFirstToken().Source~='(')then P.SemicolonList[Q-1]=nil end if not P.SemicolonList[Q-1]then N(S:GetLastToken(),R:GetFirstToken())end end end P.SemicolonList[#P.StatementList]=nil if#P.StatementList>0 then M(P.StatementList[1]:GetFirstToken())end elseif P.Type=='BreakStat'then M(P.Token_Break)elseif P.Type=='ContinueStat'then M(P.Token_Continue)elseif P.Type=='ReturnStat'then M(P.Token_Return)for Q,R in pairs(P.ExprList)do L(R)if P.Token_CommaList[Q]then M(P.Token_CommaList[Q])end end if#P.ExprList>0 then N(P.Token_Return,P.ExprList[1]:GetFirstToken())end elseif P.Type=='LocalVarStat'then M(P.Token_Local)for Q,R in pairs(P.VarList)do if Q==1 then N(P.Token_Local,R)else M(R)end local S=P.Token_VarCommaList[Q]if S then M(S)end end if P.Token_Equals then M(P.Token_Equals)for Q,R in pairs(P.ExprList)do L(R)local S=P.Token_ExprCommaList[Q]if S then M(S)end end end elseif P.Type=='LocalFunctionStat'then M(P.Token_Local)N(P.Token_Local,P.FunctionStat.Token_Function)N(P.FunctionStat.Token_Function,P.FunctionStat.NameChain[1])N(P.FunctionStat.NameChain[1],P.FunctionStat.Token_OpenParen)for Q,R in pairs(P.FunctionStat.ArgList)do M(R)local S=P.FunctionStat.Token_ArgCommaList[Q]if S then M(S)end end M(P.FunctionStat.Token_CloseParen)O(P.FunctionStat.Token_CloseParen,P.FunctionStat.Body,P.FunctionStat.Token_End)elseif P.Type=='FunctionStat'then M(P.Token_Function)for Q,R in pairs(P.NameChain)do if Q==1 then N(P.Token_Function,R)else M(R)end local S=P.Token_NameChainSeparator[Q]if S then M(S)end end M(P.Token_OpenParen)for Q,R in pairs(P.ArgList)do M(R)local S=P.Token_ArgCommaList[Q]if S then M(S)end end M(P.Token_CloseParen)O(P.Token_CloseParen,P.Body,P.Token_End)elseif P.Type=='RepeatStat'then M(P.Token_Repeat)O(P.Token_Repeat,P.Body,P.Token_Until)L(P.Condition)N(P.Token_Until,P.Condition:GetFirstToken())elseif P.Type=='GenericForStat'then M(P.Token_For)for Q,R in pairs(P.VarList)do if Q==1 then N(P.Token_For,R)else M(R)end local S=P.Token_VarCommaList[Q]if S then M(S)end end N(P.VarList[#P.VarList],P.Token_In)for Q,R in pairs(P.GeneratorList)do L(R)if Q==1 then N(P.Token_In,R:GetFirstToken())end local S=P.Token_GeneratorCommaList[Q]if S then M(S)end end N(P.GeneratorList[#P.GeneratorList]:GetLastToken(),P.Token_Do)O(P.Token_Do,P.Body,P.Token_End)elseif P.Type=='NumericForStat'then M(P.Token_For)for Q,R in pairs(P.VarList)do if Q==1 then N(P.Token_For,R)else M(R)end local S=P.Token_VarCommaList[Q]if S then M(S)end end N(P.VarList[#P.VarList],P.Token_Equals)for Q,R in pairs(P.RangeList)do L(R)if Q==1 then N(P.Token_Equals,R:GetFirstToken())end local S=P.Token_RangeCommaList[Q]if S then M(S)end end N(P.RangeList[#P.RangeList]:GetLastToken(),P.Token_Do)O(P.Token_Do,P.Body,P.Token_End)elseif P.Type=='WhileStat'then M(P.Token_While)L(P.Condition)M(P.Token_Do)N(P.Token_While,P.Condition:GetFirstToken())N(P.Condition:GetLastToken(),P.Token_Do)O(P.Token_Do,P.Body,P.Token_End)elseif P.Type=='DoStat'then M(P.Token_Do)M(P.Token_End)O(P.Token_Do,P.Body,P.Token_End)elseif P.Type=='IfStat'then M(P.Token_If)L(P.Condition)N(P.Token_If,P.Condition:GetFirstToken())N(P.Condition:GetLastToken(),P.Token_Then)local Q=P.Token_Then local R=P.Body for S,T in pairs(P.ElseClauseList)do O(Q,R,T.Token)Q=T.Token if T.Condition then L(T.Condition)N(T.Token,T.Condition:GetFirstToken())N(T.Condition:GetLastToken(),T.Token_Then)Q=T.Token_Then end K(T.Body)R=T.Body end O(Q,R,P.Token_End)elseif P.Type=='CallExprStat'then L(P.Expression)elseif P.Type=='AssignmentStat'then for Q,R in pairs(P.Lhs)do L(R)local S=P.Token_LhsSeparatorList[Q]if S then M(S)end end M(P.Token_Equals)for Q,R in pairs(P.Rhs)do L(R)local S=P.Token_RhsSeparatorList[Q]if S then M(S)end end else assert(false,"unreachable")end end K(J)end local E={}for J=('a'):byte(),('z'):byte()do table.insert(E,string.char(J))end for J=('A'):byte(),('Z'):byte()do table.insert(E,string.char(J))end for J=('0'):byte(),('9'):byte()do table.insert(E,string.char(J))end table.insert(E,'_')local F={}for J=('a'):byte(),('z'):byte()do table.insert(F,string.char(J))end for J=('A'):byte(),('Z'):byte()do table.insert(F,string.char(J))end local function G(J)local K=''local L=J%#F J=(J-L)/#F K=K..F[L+1]while J>0 do L=J%#E J=(J-L)/#E K=K..E[L+1]end return K end local function H(J,K)local L={}local M=0 for P,Q in pairs(J)do if Q.AssignedTo then else L[Q.Name]=true end end local N=0 for P,Q in pairs(J)do if Q.AssignedTo then end end K.FirstFreeName=N local function O(P)for Q,R in pairs(P.VariableList)do local S repeat S=G(P.FirstFreeName)P.FirstFreeName=P.FirstFreeName+1 until not p[S]and not L[S]R:Rename(S)end for Q,R in pairs(P.ChildScopeList)do R.FirstFreeName=P.FirstFreeName O(R)end end O(K)end local function I(J,K)local L=1 local M=1 local function N(P,Q)P.Name=Q for R,S in pairs(P.RenameList)do S(Q)end end for P,Q in pairs(J)do if Q.AssignedTo then N(Q,'G_'..M)M=M+1 end end local function O(P)for Q,R in pairs(P.VariableList)do local S='L_'..L..'_'if R.Info.Type=='Argument'then S=S..'arg'..R.Info.Index elseif R.Info.Type=='LocalFunction'then S=S..'func'elseif R.Info.Type=='ForRange'then S=S..'forvar'..R.Info.Index end N(R,S)L=L+1 end for Q,R in pairs(P.ChildScopeList)do O(R)end end O(K)end function minify(J)local K=x(J)local L,M=z(K)H(L,M)D(K)return A(K)end function beautify(J,K)local L=x(J)local M,N=z(L)if K then I(M,N)end C(L)return A(L)end
--[[
	func minify(str) return str
	func beautify(str) return str
]]
